"area"),
# tables to join the description
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.classi_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
)
# which shape to read
if(points){
path_spatial = points_landslide_path
}else{
path_spatial = poly_landslide_path
}
path_spatial
# we want the point data
points = T
# which shape to read
if(points){
path_spatial = points_landslide_path
}else{
path_spatial = poly_landslide_path
}
path_spatial
# query the landslide data and its attributes -----------------------------
res = iffitoR::make_shapefile(database_dir = database_dir,
attribute_database_name = "tbl_frane",
# the name without extension
dictionary_database_name = "diz_frane",
shapefile = path_spatial,
# normally null only setting it here for me
# the colums we want to retrieve directly
attri = c("anno_min",
"mese_min",
"giorno_min",
"area"),
# tables to join the description
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.classi_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
)
if(os == "Linux"){
path_ncdf = "/mnt/CEPH_PROJECTS/Proslide/PREC_GRIDS_updated/"
poly_landslide_path = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_4/IFFI10_4.shp"
points_landslide_path = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_1/IFFI10_1.shp"
database_dir = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffi_db_1821_to_2020/IFFI_access300321/IFFI/"
}else if(os == "Windows"){
path_ncdf = "\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS_updated/"
poly_landslide_path = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_4/IFFI10_4.shp"
points_landslide_path = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp"
points_landslide_path_2020 = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_1/IFFI10_1.shp"
database_dir = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/iffi_db_1821_to_2020/IFFI_access300321/IFFI/"
database_dir_2020 = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/iffi_db_1821_to_2020/IFFI_access300321/IFFI/"
}else{
stop(call. = F, "what the hell are you working on...")
}
# which shape to read
if(points){
path_spatial = points_landslide_path
}else{
path_spatial = poly_landslide_path
}
path_spatial
# query the landslide data and its attributes -----------------------------
res = iffitoR::make_shapefile(database_dir = database_dir,
attribute_database_name = "tbl_frane",
# the name without extension
dictionary_database_name = "diz_frane",
shapefile = path_spatial,
# normally null only setting it here for me
# the colums we want to retrieve directly
attri = c("anno_min",
"mese_min",
"giorno_min",
"area"),
# tables to join the description
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.classi_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
)
database_dir = database_dir
database_dir
if(os == "Linux"){
path_ncdf = "/mnt/CEPH_PROJECTS/Proslide/PREC_GRIDS_updated/"
poly_landslide_path = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_4/IFFI10_4.shp"
points_landslide_path = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_1/IFFI10_1.shp"
database_dir = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffi_db_1821_to_2020/IFFI_access300321/IFFI/"
}else if(os == "Windows"){
path_ncdf = "\\\\projectdata.eurac.edu/projects/Proslide/PREC_GRIDS_updated/"
poly_landslide_path = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_4/IFFI10_4.shp"
points_landslide_path = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/Shapefiles/IFFI10_1.shp"
points_landslide_path_2020 = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/iffi_db_1821_to_2020/shapefile/IFFI10_1/IFFI10_1.shp"
database_dir = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/Iffi_db_xxxx_to_2018/exportperEurac2020/database"
database_dir_2020 = "\\\\projectdata.eurac.edu/projects/Proslide/Landslides/iffi_db_1821_to_2020/IFFI_access300321/IFFI/"
}else{
stop(call. = F, "what the hell are you working on...")
}
# which shape to read
if(points){
path_spatial = points_landslide_path
}else{
path_spatial = poly_landslide_path
}
path_spatial
database_dir
# query the landslide data and its attributes -----------------------------
res = iffitoR::make_shapefile(database_dir = database_dir,
attribute_database_name = "tbl_frane",
# the name without extension
dictionary_database_name = "diz_frane",
shapefile = path_spatial,
# normally null only setting it here for me
# the colums we want to retrieve directly
attri = c("anno_min",
"mese_min",
"giorno_min",
"area"),
# tables to join the description
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.classi_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
)
database_dir
attribute_database_name = "tbl_frane"
dictionary_database_name = "diz_frane"
shapefile = path_spatial
attri = c("anno_min",
"mese_min",
"giorno_min",
"area")
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.classi_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
# establish connections
conns = set_connection(database_dir)
conns
# set the right ones
# there are some issues with indexing the list, for some reason we need to index conns with [[]]
# to maintain a valid and open connection
index_attr = which(grepl(attribute_database_name, names(conns)))
index_attr
if (!is.null(dictionary_database_name)) {
index_dict = which(grepl(dictionary_database_name, names(conns)))
}
attr_database_conn = conns[[index_attr]]
if (!is.null(dictionary_database_name)) {
dict_database_conn = conns[[index_dict]]
}
# the table names are the attributes we can query
# Especially the one in the attributes table are interesting
table_names_attr = make_vector_table_names(attr_database_conn)
if (!is.null(dictionary_database_name)) {
table_names_dict = make_vector_table_names(dict_database_conn)
}
# make a list of dataframes(tables) for the attributes database
dfs_attr = make_list_dataframes(attr_database_conn)
dfs_attr
names(dfs_attr)
# make a list of dataframes(tables) for the dictionary database
if (!is.null(dictionary_database_name)) {
dfs_dict = make_list_dataframes(dict_database_conn)
}
# check for each dataframe if they have an id and subid column
log_vec = check_id(dfs_attr)
devtools::load_all()
# check for each dataframe if they have an id and subid column
log_vec = check_id(dfs_attr)
# for the rest create the iffi index for the attribute tables
dfs_attr_iffi = create_iffi_index(dfs_attr, log_vec)
# find the tables that we can join directly
tables_to_append_diretly = find_tables(dfs_attr_iffi, attri)
### join those tables
# read the shape
shape = read_shape(shapefile)
shape_joined_attri = join_shape_attributes(shape, tables_to_append_diretly, dfs_attr_iffi)
dim(shape_joined_attri)
# make the joins to the dictionary
if (!is.null(dictionary_database_name) | !is.null(joins)) {
joined_dicionary_tables_with_iffi_kodex = join_descriptions(joins, dfs_attr_iffi, dfs_dict)
}
dfs_dict
# list of joined tables
joined_tables = vector("list")
# make them all lower case
joins = lapply(joins, tolower)
names(joins) = tolower(names(joins))
# make a vector of the three
elements_in_join = c(names(joins)[[i]], joins[[i]][[1]], joins[[i]][[2]]) %>% tolower(.)
i =1
# make a vector of the three
elements_in_join = c(names(joins)[[i]], joins[[i]][[1]], joins[[i]][[2]]) %>% tolower(.)
elements_in_join
# assert that all have 3 entries (db, table, col)
length_attri = elements_in_join[[1]] %>% stringr::str_split(., pattern = "\\.") %>% unlist() %>% length()
length_diz_key = elements_in_join[[2]] %>% stringr::str_split(., pattern = "\\.") %>% unlist() %>% length()
length_diz_value = elements_in_join[[3]] %>% stringr::str_split(., pattern = "\\.") %>% unlist() %>% length()
# vector of the three lengths
ll = c(length_attri, length_diz_key, length_diz_value)
for (l in seq_along(ll)) {
if (ll[[l]] != 3) {
stop(call. = FALSE, paste0("You gave a wrong joins attribute\n", elements_in_join[[l]] ,"\n does not thave the three elements <database>.<table>.<column>"))
}
}
# get the database, Table, column of the attribute datbase
table_attri = names(joins)[[i]] %>% stringr::str_split(., pattern = "\\.") %>% .[[1]] %>% .[[2]]
col_attri = names(joins)[[i]] %>% stringr::str_split(., pattern = "\\.") %>% .[[1]] %>% .[[3]]
table_attri
col_attri
# find the attribute table
df_index = grep(pattern = paste0("^", table_attri, "$"), names(dfs_attr_iffi))
df_index
table_attri
names(dfs_attr_iffi)
# make a list of dataframes(tables) for the attributes database
dfs_attr = make_list_dataframes(attr_database_conn)
names(dfs_attr)
list_of_dfs = dfs_attr
log_idx
log_idx = log_vec
log_idx
names(list_of_dfs)
df = 1
# get the indices of id and subid
colnames_df = names(list_of_dfs[[df]])
colnames_df
id_idx = which(grepl("\\bid\\b", colnames_df, ignore.case = TRUE))
subid_idx = which(grepl("\\bsubid\\b", colnames_df, ignore.case = TRUE))
id = list_of_dfs[[df]][[id_idx]] * 10000
subid = list_of_dfs[[df]][[subid_idx]] * 100
iffi_kodex = id + subid + 00
iffi_kodex
# for the rest create the iffi index for the attribute tables
dfs_attr_iffi = create_iffi_index(dfs_attr, log_vec)
dfs_attr_iffi
names(dfs_attr_iffi)
# find the tables that we can join directly
tables_to_append_diretly = find_tables(dfs_attr_iffi, attri)
### join those tables
# read the shape
shape = read_shape(shapefile)
shape_joined_attri = join_shape_attributes(shape, tables_to_append_diretly, dfs_attr_iffi)
# make the joins to the dictionary
if (!is.null(dictionary_database_name) | !is.null(joins)) {
joined_dicionary_tables_with_iffi_kodex = join_descriptions(joins, dfs_attr_iffi, dfs_dict)
}
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.clas_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
# make the joins to the dictionary
if (!is.null(dictionary_database_name) | !is.null(joins)) {
joined_dicionary_tables_with_iffi_kodex = join_descriptions(joins, dfs_attr_iffi, dfs_dict)
}
joins
# make the joins to the dictionary
if (!is.null(dictionary_database_name) | !is.null(joins)) {
joined_dicionary_tables_with_iffi_kodex = join_descriptions(joins, dfs_attr_iffi, dfs_dict)
}
joins
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.clas_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.clas_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
# make the joins to the dictionary
if (!is.null(dictionary_database_name) | !is.null(joins)) {
joined_dicionary_tables_with_iffi_kodex = join_descriptions(joins, dfs_attr_iffi, dfs_dict)
}
# join them to the shape
if (!is.null(dictionary_database_name) | !is.null(joins)) {
final_joined = join_descriptions_shape(joined_dicionary_tables_with_iffi_kodex, shape_joined_attri)
}
# filter the columns we wanted
final_selected = select_cols(final_joined, attri, joins)
# query the landslide data and its attributes -----------------------------
res = iffitoR::make_shapefile(database_dir = database_dir,
attribute_database_name = "tbl_frane",
# the name without extension
dictionary_database_name = "diz_frane",
shapefile = path_spatial,
# normally null only setting it here for me
# the colums we want to retrieve directly
attri = c("anno_min",
"mese_min",
"giorno_min",
"area"),
# tables to join the description
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.clas_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.clas_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
)
# translate to english
res_eng = iffitoR::translate_iffi(res)
# add time information
landsld = iffitoR::get_date_information(res_eng)
landsld_old = landsld %>% st_transform(., 32632)
# save it
usethis::use_data(landsld_old, overwrite = T)
# which shape to read
if(points){
path_spatial = points_landslide_path_2020
}else{
path_spatial = poly_landslide_path
}
path_spatial
# query the landslide data and its attributes -----------------------------
res = iffitoR::make_shapefile(database_dir = database_dir_2020,
attribute_database_name = "reconstructed",
# the name without extension
dictionary_database_name = "diz_frane",
shapefile = path_spatial,
# normally null only setting it here for me
# the colums we want to retrieve directly
attri = c("anno_min",
"mese_min",
"giorno_min",
"area"),
# tables to join the description
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.classi_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
)
# query the landslide data and its attributes -----------------------------
res = iffitoR::make_shapefile(database_dir = "../../iffi_raw_daniel/exportperEurac2021/IFFI_Stand_31.03.2021/IFFI_access300321/IFFI/",
attribute_database_name = "reconstructed",
# the name without extension
dictionary_database_name = "diz_frane",
shapefile = path_spatial,
# normally null only setting it here for me
# the colums we want to retrieve directly
attri = c("anno_min",
"mese_min",
"giorno_min",
"area"),
# tables to join the description
joins = list(
"tbl_frane.Generalita.Cod_tipo" = c(
"diz_frane.diz_tipo_movi.cod_tipo",
"diz_frane.diz_tipo_movi.tipologia"
),
"tbl_frane.classi_ii_liv.materiale" = c(
"diz_frane.diz_materiali.materiale",
"diz_frane.diz_materiali.nome_materiale"
),
"tbl_frane.classi_ii_liv.movimento" = c(
"diz_frane.diz_movimenti.movimento",
"diz_frane.diz_movimenti.nome_movimento"
),
"tbl_frane.ass_gen_cause.causa" = c(
"diz_frane.diz_cause.causa",
"diz_frane.diz_cause.nome_causa"
)
)
)
dim(res)
# translate to english
res_eng = iffitoR::translate_iffi(res)
# add time information
landsld = iffitoR::get_date_information(res_eng)
landsld = landsld %>% st_transform(., 32632)
# save it
usethis::use_data(landsld, overwrite = T)
# save it
usethis::use_data(landsld, overwrite = T)
dim(landsld)
read("../../../Desktop/test.Rdata")
readRDS("../../../Desktop/test.Rdata")
c
c = readRDS("../../../Desktop/test.Rdata")
dim(c)
unique(c$years)
ggplot(c) + geom_raster(aes(x=x,y=y, fill=values))
library(tidyverse)
library(gganimate)
ggplot(c) + geom_raster(aes(x=x,y=y, fill=values))
ggplot(c) + geom_raster(aes(x=x,y=y, fill=values)) + transition_states(years)
c = readRDS("../../../Desktop/test.Rdata")
ggplot(c) + geom_raster(aes(x=x,y=y, fill=values))
ggplot(c) + geom_raster(aes(x=x,y=y, fill=values)) + transition_states(years)
c$year
ggplot(c) + geom_raster(aes(x=x,y=y, fill=values)) + transition_states(year)
ggplot(c) + geom_boxplot(aes(x = values, fill=year))
